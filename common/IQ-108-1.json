{
  "title": "Git Connection Validation - Complete",
  "test_description": "Complete Git connection validation including credential creation, repository access, file upload to GitHub, and repository sync validation. Tests the entire Git integration workflow in a single test.",
  "version": "3.1",
  "test_code": "IQ-108-1",
  "test_seq": 1,
  "test_suite": "IQ-108",
  "test_suite_title": "Git Connection Validation",
  "test_type": "Workspace",
  "category": "IQ",
  "api_calls": [
    {
      "step": 1,
      "name": "get_current_user",
      "method": "GET",
      "api_url": "${workspace_url}/api/2.0/preview/scim/v2/Me",
      "headers": {
        "Authorization": "Bearer ${token}",
        "Content-Type": "application/json"
      },
      "payload": {},
      "post_processing": "function processStep(responseData, currentVariables) { const userName = responseData.userName || 'validation-user'; const currentTimestamp = Date.now().toString(); const repoUrl = currentVariables.repo_url || ''; let gitRepoOwner = ''; let gitRepoName = ''; if (repoUrl) { const urlParts = repoUrl.replace('https://github.com/', '').split('/'); if (urlParts.length >= 2) { gitRepoOwner = urlParts[0]; gitRepoName = urlParts[1]; } } return { ...currentVariables, user_name: userName, current_timestamp: currentTimestamp, git_repo_owner: gitRepoOwner, git_repo_name: gitRepoName }; }"
    },
    {
      "step": 2,
      "name": "check_existing_credentials",
      "method": "GET",
      "api_url": "${workspace_url}/api/2.0/git-credentials",
      "headers": {
        "Authorization": "Bearer ${token}",
        "Content-Type": "application/json"
      },
      "payload": {},
      "post_processing": "function processStep(responseData, currentVariables) { const credentials = responseData.credentials || []; let existingCredentialId = null; let hasCredentials = credentials.length > 0; if (hasCredentials) { for (let i = 0; i < credentials.length; i++) { const cred = credentials[i]; if (cred && cred.git_provider && cred.git_username && cred.git_provider.toLowerCase() === currentVariables.git_provider.toLowerCase() && cred.git_username === currentVariables.git_username) { existingCredentialId = cred.credential_id; break; } } if (!existingCredentialId && credentials.length > 0) { existingCredentialId = credentials[0].credential_id; } } return { ...currentVariables, has_credentials: hasCredentials, existing_credential_id: existingCredentialId, credentials_count: credentials.length }; }"
    },
    {
      "step": 3,
      "name": "create_or_update_credentials",
      "method": "POST",
      "api_url": "${workspace_url}/api/2.0/git-credentials",
      "headers": {
        "Authorization": "Bearer ${token}",
        "Content-Type": "application/json"
      },
      "payload": {
        "git_provider": "${git_provider}",
        "git_username": "${git_username}",
        "personal_access_token": "${personal_access_token}"
      },
      "post_processing": "function processStep(responseData, currentVariables, response) { const credentialId = responseData?.credential_id || currentVariables.existing_credential_id; const statusCode = response && response.status ? response.status : 200; const isUpdate = currentVariables.has_credentials && currentVariables.existing_credential_id; const isCreated = statusCode === 200 && credentialId; const alreadyExists = statusCode === 400 && (responseData?.message || '').toLowerCase().includes('already exists'); const success = isCreated || isUpdate || alreadyExists; return { ...currentVariables, credential_id: credentialId, credentials_created: success, credentials_updated: isUpdate, credentials_already_exist: alreadyExists, credential_operation_success: success }; }"
    },
    {
      "step": 4,
      "name": "check_repository_exists",
      "method": "GET",
      "api_url": "${workspace_url}/api/2.0/repos",
      "headers": {
        "Authorization": "Bearer ${token}",
        "Content-Type": "application/json"
      },
      "payload": {},
      "post_processing": "function processStep(responseData, currentVariables) { const repos = responseData.repos || []; const repoFound = repos.some(repo => repo.url === currentVariables.repo_url); const repoId = repoFound ? repos.find(repo => repo.url === currentVariables.repo_url).id : null; const repoPath = repoFound ? repos.find(repo => repo.url === currentVariables.repo_url).path : null; return { ...currentVariables, repo_exists: repoFound, repo_id: repoId, repo_path: repoPath }; }"
    },
    {
      "step": 5,
      "name": "create_repository_if_needed",
      "method": "POST",
      "api_url": "${workspace_url}/api/2.0/repos",
      "headers": {
        "Authorization": "Bearer ${token}",
        "Content-Type": "application/json"
      },
      "payload": {
        "url": "${repo_url}",
        "provider": "${git_provider}",
        "path": "/Users/${user_name}/iq-oq-validation-repo-${current_timestamp}",
        "branch": "main",
        "sparse_checkout": {
          "patterns": [
            "src",
            "test"
          ]
        }
      },
      "post_processing": "function processStep(responseData, currentVariables, response) { const statusCode = response && response.status ? response.status : 200; const repoId = responseData?.id || currentVariables.repo_id; const repoPath = responseData?.path || currentVariables.repo_path; const isCreated = statusCode === 200 && repoId; const alreadyExists = statusCode === 400 && (responseData?.message || '').toLowerCase().includes('already exists'); const success = isCreated || alreadyExists || currentVariables.repo_exists; return { ...currentVariables, repo_id: repoId, repo_path: repoPath, repo_created: isCreated, repo_already_exists: alreadyExists, repo_operation_success: success }; }"
    },
    {
      "step": 6,
      "name": "list_initial_repository_contents",
      "method": "GET",
      "api_url": "${workspace_url}/api/2.0/workspace/list",
      "headers": {
        "Authorization": "Bearer ${token}",
        "Content-Type": "application/json"
      },
      "payload": {
        "path": "${repo_path}"
      },
      "post_processing": "function processStep(responseData, currentVariables) { const objects = responseData.objects || []; const initialFileCount = objects.length; const hasFiles = initialFileCount > 0; const initialFiles = objects.map(obj => obj.path); return { ...currentVariables, initial_file_count: initialFileCount, initial_files: initialFiles, has_files: hasFiles }; }"
    },
    {
      "step": 7,
      "name": "upload_file_to_github",
      "method": "PUT",
      "api_url": "https://api.github.com/repos/${git_repo_owner}/${git_repo_name}/contents/test-sync-file-${current_timestamp}.txt",
      "headers": {
        "Authorization": "Bearer ${personal_access_token}",
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
        "Content-Type": "application/json"
      },
      "payload": {
        "message": "Test file for Databricks sync validation - ${current_timestamp}",
        "content": "VGhpcyBpcyBhIHRlc3QgZmlsZSBmb3IgdmFsaWRhdGluZyBEYXRhYnJpY2tzIEdpdCBzeW5jIGZ1bmN0aW9uYWxpdHkuIENyZWF0ZWQgYXQ6ICR7Y3VycmVudF90aW1lc3RhbXB9",
        "branch": "main",
        "author": {
          "name": "Databricks Test User",
          "email": "${git_username}"
        }
      },
      "post_processing": "function processStep(responseData, currentVariables, response) { const statusCode = response && response.status ? response.status : 200; const isUploaded = statusCode === 200 || statusCode === 201; const fileSha = responseData?.content?.sha || null; const filePath = responseData?.content?.path || null; const downloadUrl = responseData?.content?.download_url || null; return { ...currentVariables, file_uploaded: isUploaded, uploaded_file_sha: fileSha, uploaded_file_path: filePath, uploaded_file_url: downloadUrl, upload_status_code: statusCode }; }"
    },
    {
      "step": 8,
      "name": "trigger_repository_sync",
      "method": "PATCH",
      "api_url": "${workspace_url}/api/2.0/repos/${repo_id}",
      "headers": {
        "Authorization": "Bearer ${token}",
        "Content-Type": "application/json"
      },
      "payload": {
        "branch": "main"
      },
      "post_processing": "async function processStep(responseData, currentVariables) { const success = responseData?.id ? true : false; if (!success) { return { ...currentVariables, sync_triggered: false }; } const uploadedFileName = currentVariables.uploaded_file_path ? currentVariables.uploaded_file_path.split('/').pop() : null; if (!uploadedFileName) { return { ...currentVariables, sync_triggered: success, sync_completed: false, polling_completed: true, uploaded_file_found: false }; } const startTime = Date.now(); const pollInterval = 15000; let pollAttempts = 0; const maxAttempts = 20; while (pollAttempts < maxAttempts) { pollAttempts++; try { const response = await axios.get(`${currentVariables.workspace_url}/api/2.0/workspace/list`, { headers: { 'Authorization': `Bearer ${currentVariables.token}`, 'Content-Type': 'application/json' }, params: { path: currentVariables.repo_path } }); const objects = response.data.objects || []; const fileFound = uploadedFileName ? objects.some(obj => obj.path && obj.path.includes(uploadedFileName)) : false; if (fileFound) { const elapsedTime = (Date.now() - startTime) / 1000; return { ...currentVariables, sync_triggered: success, sync_completed: true, polling_completed: true, poll_attempts: pollAttempts, sync_time_seconds: elapsedTime, uploaded_file_found: true }; } else { if (pollAttempts < maxAttempts) { try { await axios.patch(`${currentVariables.workspace_url}/api/2.0/repos/${currentVariables.repo_id}`, { branch: 'main' }, { headers: { 'Authorization': `Bearer ${currentVariables.token}`, 'Content-Type': 'application/json' } }); } catch (syncError) { } await delay(pollInterval); } } } catch (error) { if (pollAttempts < maxAttempts) { await delay(pollInterval); } } } const elapsedTime = (Date.now() - startTime) / 1000; return { ...currentVariables, sync_triggered: success, sync_completed: false, polling_completed: true, poll_attempts: maxAttempts, polling_timeout: true, sync_time_seconds: elapsedTime, uploaded_file_found: false }; }"
    },
    {
      "step": 9,
      "name": "validate_sync_completion",
      "method": "GET",
      "api_url": "${workspace_url}/api/2.0/workspace/list",
      "headers": {
        "Authorization": "Bearer ${token}",
        "Content-Type": "application/json"
      },
      "payload": {
        "path": "${repo_path}"
      },
      "post_processing": "function processStep(responseData, currentVariables) { const objects = responseData.objects || []; const uploadedFileName = currentVariables.uploaded_file_path ? currentVariables.uploaded_file_path.split('/').pop() : null; const fileFound = uploadedFileName ? objects.some(obj => obj.path && obj.path.includes(uploadedFileName)) : false; const syncValidated = fileFound && currentVariables.uploaded_file_found; return { ...currentVariables, sync_validation_completed: true, final_file_found: fileFound, sync_validated: syncValidated }; }"
    },
    {
      "step": 10,
      "name": "validate_repository_access",
      "method": "GET",
      "api_url": "${workspace_url}/api/2.0/repos",
      "headers": {
        "Authorization": "Bearer ${token}",
        "Content-Type": "application/json"
      },
      "payload": {},
      "post_processing": "function processStep(responseData, currentVariables) { const repos = responseData.repos || []; const repoFound = repos.some(repo => repo.url === currentVariables.repo_url); const accessValidated = repoFound || currentVariables.repo_operation_success; return { ...currentVariables, repository_access_validated: accessValidated, final_repo_found: repoFound }; }"
    },
    {
      "step": 11,
      "name": "delete_test_file_from_github",
      "method": "DELETE",
      "api_url": "https://api.github.com/repos/${git_repo_owner}/${git_repo_name}/contents/test-sync-file-${current_timestamp}.txt",
      "headers": {
        "Authorization": "Bearer ${personal_access_token}",
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
        "Content-Type": "application/json"
      },
      "payload": {
        "message": "Cleanup: Remove test file after sync validation - ${current_timestamp}",
        "sha": "${uploaded_file_sha}",
        "branch": "main",
        "committer": {
          "name": "Databricks Test User",
          "email": "${git_username}"
        }
      },
      "post_processing": "function processStep(responseData, currentVariables, response) { const statusCode = response && response.status ? response.status : 200; const isDeleted = statusCode === 200; const commitSha = responseData?.commit?.sha || null; return { ...currentVariables, file_deleted: isDeleted, deletion_commit_sha: commitSha, deletion_status_code: statusCode }; }"
    }
  ],
  "response_schema": null,
  "parser_code": "function aggregateResults(stepResults) { const userStep = stepResults.get_current_user; const credentialsStep = stepResults.check_existing_credentials; const createCredentialsStep = stepResults.create_or_update_credentials; const checkRepoStep = stepResults.check_repository_exists; const createRepoStep = stepResults.create_repository_if_needed; const listStep = stepResults.list_initial_repository_contents; const uploadStep = stepResults.upload_file_to_github; const syncStep = stepResults.trigger_repository_sync; const validateSyncStep = stepResults.validate_sync_completion; const validateAccessStep = stepResults.validate_repository_access; const deleteStep = stepResults.delete_test_file_from_github; const expected_result = 'Complete Git connection validation: credentials created, file uploaded to GitHub, sync validated, and cleanup completed'; let actual_result = 'Git connection validation not completed'; if (!userStep || !userStep.data || !userStep.data.userName) { actual_result = 'Failed to get user information.'; return { status: 'fail', message: actual_result, code: 'GET_USER_FAILED', test_id: 'IQ-108-1', title: 'Git Connection Validation - Complete', expected_result, actual_result }; } if (!createCredentialsStep || !createCredentialsStep.data || !variables.credential_operation_success) { actual_result = 'Failed to create or verify Git credentials.'; return { status: 'fail', message: actual_result, code: 'CREDENTIALS_FAILED', test_id: 'IQ-108-1', title: 'Git Connection Validation - Complete', expected_result, actual_result }; } if (!createRepoStep || !createRepoStep.data || !variables.repo_operation_success) { actual_result = 'Failed to create or find repository.'; return { status: 'fail', message: actual_result, code: 'REPO_CREATION_FAILED', test_id: 'IQ-108-1', title: 'Git Connection Validation - Complete', expected_result, actual_result }; } if (!uploadStep || !uploadStep.data || !variables.file_uploaded) { actual_result = 'Failed to upload file to GitHub.'; return { status: 'fail', message: actual_result, code: 'FILE_UPLOAD_FAILED', test_id: 'IQ-108-1', title: 'Git Connection Validation - Complete', expected_result, actual_result }; } if (!syncStep || !syncStep.data || !variables.sync_triggered) { actual_result = 'Failed to trigger repository sync.'; return { status: 'fail', message: actual_result, code: 'SYNC_TRIGGER_FAILED', test_id: 'IQ-108-1', title: 'Git Connection Validation - Complete', expected_result, actual_result }; } if (!variables.polling_completed) { actual_result = 'Failed to complete repository sync polling.'; return { status: 'fail', message: actual_result, code: 'POLLING_INCOMPLETE', test_id: 'IQ-108-1', title: 'Git Connection Validation - Complete', expected_result, actual_result }; } if (!validateAccessStep || !validateAccessStep.data || !variables.repository_access_validated) { actual_result = 'Failed to validate repository access.'; return { status: 'fail', message: actual_result, code: 'REPO_ACCESS_FAILED', test_id: 'IQ-108-1', title: 'Git Connection Validation - Complete', expected_result, actual_result }; } if (variables.uploaded_file_found) { const pollAttempts = variables.poll_attempts || 0; const syncTime = variables.sync_time_seconds || 0; const uploadedFileName = variables.uploaded_file_path ? variables.uploaded_file_path.split('/').pop() : 'test file'; const cleanupStatus = variables.file_deleted ? ' and cleanup completed' : ' (cleanup failed)'; actual_result = `Complete Git validation successful: credentials created, file '${uploadedFileName}' uploaded to GitHub and synced to Databricks after ${pollAttempts} polling attempts in ${syncTime.toFixed(2)} seconds${cleanupStatus}.`; return { status: 'pass', message: 'Credential creation and repository sync passed', code: 'REPO_SYNC_VALIDATED', test_id: 'IQ-108-1', title: 'Git Connection Validation - Complete', expected_result, actual_result }; } else { const syncTime = variables.sync_time_seconds || 0; const pollAttempts = variables.poll_attempts || 0; if (variables.polling_timeout) { actual_result = `Git validation completed but uploaded file did not sync within time limit (${syncTime.toFixed(2)} seconds after ${pollAttempts} polling attempts).`; return { status: 'fail', message: actual_result, code: 'SYNC_TIMEOUT', test_id: 'IQ-108-1', title: 'Git Connection Validation - Complete', expected_result, actual_result }; } else { actual_result = `Git validation completed - credentials and access validated, file upload successful, sync process initiated. Sync time: ${syncTime.toFixed(2)} seconds.`; return { status: 'pass', message: 'Git validation completed - credentials, file upload, and access validated, sync process initiated successfully', code: 'REPO_SYNC_PARTIAL', test_id: 'IQ-108-1', title: 'Git Connection Validation - Complete', expected_result, actual_result }; } } }",
  "manual_procedure": "Get user info, check existing Git credentials, create or update Git credentials, check repository exists, create repository if needed, list initial contents, upload test file to GitHub, trigger sync and poll for completion (up to 5 minutes), validate sync completion, and validate repository access."
} 